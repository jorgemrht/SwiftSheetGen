import Testing
import Foundation
@testable import SheetLocalizer

@Suite
struct FileGeneratorTests {
    
    // MARK: - SwiftEnumGenerator Tests
    
    @Test("SwiftEnumGenerator creates comprehensive localization enums with proper structure and methods")
    func swiftEnumGeneratorBasicCodeGeneration() {
        let generator = SwiftEnumGenerator(enumName: "L10n")
        let keys = ["common_app_name_text", "login_title_text", "profile_version_text"]
        
        let code = generator.generateCode(allKeys: keys)
        
        #expect(code.contains("public enum L10n: String, CaseIterable, Sendable"), "Generated enum should have proper declaration with protocols")
        #expect(code.contains("@frozen"), "Generated enum should be marked as frozen for performance")
        #expect(code.contains("import Foundation"), "Generated code should import Foundation")
        #expect(code.contains("import SwiftUI"), "Generated code should import SwiftUI for LocalizedStringKey support")
        
        #expect(code.contains("case commonAppNameText = \"common_app_name_text\""), "Localization keys should be converted to camelCase enum cases")
        #expect(code.contains("case loginTitleText = \"login_title_text\""), "All provided keys should be included as enum cases")
        #expect(code.contains("case profileVersionText = \"profile_version_text\""), "Complex key names should be properly camelCased")
        
        #expect(code.contains("public var localized: String"), "Generated enum should provide basic localized property")
        #expect(code.contains("public func localized(_ args: CVarArg...) -> String"), "Generated enum should support formatted localization with arguments")
        #expect(code.contains("public func localized(bundle: Bundle) -> String"), "Generated enum should support custom bundle localization")
        #expect(code.contains("public var localizedString: LocalizedStringKey"), "Generated enum should provide SwiftUI LocalizedStringKey support")
    }
    
    @Test("SwiftEnumGenerator respects custom enum names for flexible code generation")
    func swiftEnumGeneratorCustomEnumNameSupport() {
        let generator = SwiftEnumGenerator(enumName: "Strings")
        let keys = ["test_key"]
        
        let code = generator.generateCode(allKeys: keys)
        
        #expect(code.contains("public enum Strings: String, CaseIterable, Sendable"), "Custom enum name should be used in generated declaration")
    }
    
    @Test("SwiftEnumGenerator handles empty key sets gracefully while maintaining proper structure")
    func swiftEnumGeneratorEmptyKeysHandling() {
        let generator = SwiftEnumGenerator(enumName: "L10n")
        let keys: [String] = []
        
        let code = generator.generateCode(allKeys: keys)
        
        #expect(code.contains("public enum L10n: String, CaseIterable, Sendable"), "Empty key set should still produce valid enum declaration")
        #expect(code.contains("public var localized: String"), "Empty enum should still include all localization methods for consistency")
    }
    
    @Test("SwiftEnumGenerator includes proper file header with generation metadata and warnings")
    func swiftEnumGeneratorGenerationMetadata() {
        let generator = SwiftEnumGenerator(enumName: "L10n")
        let keys = ["test_key"]
        
        let code = generator.generateCode(allKeys: keys)
        
        #expect(code.contains("Auto-generated by SheetLocalizer"), "Generated file should identify itself as auto-generated")
        #expect(code.contains("Generated on:"), "Generated file should include timestamp for tracking")
        #expect(code.contains("do not edit"), "Generated file should warn against manual editing")
    }
    
    @Test("SwiftEnumGenerator preserves original key values while handling identifier conflicts")
    func swiftEnumGeneratorIdentifierConflictResolution() {
        let generator = SwiftEnumGenerator(enumName: "L10n")
        
        let keys = ["test_key_1", "test.key.1", "test-key-1"]
        let code = generator.generateCode(allKeys: keys)
        
        #expect(code.contains("= \"test_key_1\""), "Original key values should be preserved as enum raw values")
        #expect(code.contains("= \"test.key.1\""), "Keys with dots should maintain original format in raw values")
        #expect(code.contains("= \"test-key-1\""), "Keys with hyphens should maintain original format in raw values")
    }
    
    // MARK: - StringsCatalogGenerator Tests
    
    @Test("StringsCatalogGenerator creates properly formatted JSON catalog with localization metadata")
    func stringsCatalogGeneratorBasicJSONGeneration() throws {
        let entries = [
            LocalizationEntry(view: "common", item: "app_name", type: "text", translations: [
                "en": "My App",
                "es": "Mi App"
            ]),
            LocalizationEntry(view: "login", item: "title", type: "text", translations: [
                "en": "Login",
                "es": "Iniciar sesiÃ³n"
            ])
        ]
        
        let data = try StringsCatalogGenerator.generate(
            for: entries,
            sourceLanguage: "en",
            developmentRegion: "en"
        )
        
        let jsonString = String(data: data, encoding: .utf8)!
        
        #expect(jsonString.contains("\"sourceLanguage\" : \"en\""), "Strings catalog should specify source language")
        #expect(jsonString.contains("\"version\" : \"1.0\""), "Strings catalog should include version metadata")
        #expect(jsonString.contains("\"common_app_name_text\""), "Generated keys should follow view_item_type format")
        #expect(jsonString.contains("\"login_title_text\""), "All localization entries should be included")
        #expect(jsonString.contains("\"My App\""), "English translations should be preserved")
        #expect(jsonString.contains("\"Mi App\""), "Spanish translations should be preserved")
        
        let jsonObject = try JSONSerialization.jsonObject(with: data)
        #expect(jsonObject is [String: Any], "Generated data should be valid JSON")
    }
    
    @Test("StringsCatalogGenerator produces valid empty catalog structure for no entries")
    func stringsCatalogGeneratorEmptyEntriesHandling() throws {
        let entries: [LocalizationEntry] = []
        
        let data = try StringsCatalogGenerator.generate(
            for: entries,
            sourceLanguage: "en",
            developmentRegion: "en"
        )
        
        let jsonString = String(data: data, encoding: .utf8)!
        
        #expect(jsonString.contains("\"sourceLanguage\" : \"en\""), "Empty catalog should still specify source language")
        #expect(jsonString.contains("\"strings\" : {"), "Empty catalog should have proper strings structure")
        
        let jsonObject = try JSONSerialization.jsonObject(with: data)
        #expect(jsonObject is [String: Any], "Empty catalog should still be valid JSON")
    }
    
    @Test("StringsCatalogGenerator handles partial translations gracefully across multiple languages")
    func stringsCatalogGeneratorPartialTranslationsHandling() throws {
        let entries = [
            LocalizationEntry(view: "common", item: "app_name", type: "text", translations: [
                "en": "My App"
            ]),
            LocalizationEntry(view: "login", item: "title", type: "text", translations: [
                "en": "Login",
                "es": "Iniciar sesiÃ³n",
                "fr": "Connexion"
            ])
        ]
        
        let data = try StringsCatalogGenerator.generate(
            for: entries,
            sourceLanguage: "en",
            developmentRegion: "en"
        )
        
        let jsonString = String(data: data, encoding: .utf8)!
        
        #expect(jsonString.contains("\"My App\""), "Source language translations should always be included")
        #expect(jsonString.contains("\"Login\""), "All available translations should be preserved")
        #expect(jsonString.contains("\"Connexion\""), "Multi-language support should include all provided translations")
        
        let jsonObject = try JSONSerialization.jsonObject(with: data)
        #expect(jsonObject is [String: Any], "Partial translations should not break JSON validity")
    }
    
    @Test("StringsCatalogGenerator properly escapes and preserves special characters in translations")
    func stringsCatalogGeneratorSpecialCharacterHandling() throws {
        let entries = [
            LocalizationEntry(view: "test", item: "special", type: "text", translations: [
                "en": "Text with \"quotes\" and newlines\nand unicode: ðŸš€",
                "es": "Texto con comillas \" y sÃ­mbolos especiales: Ã¡Ã©Ã­Ã³Ãº"
            ])
        ]
        
        let data = try StringsCatalogGenerator.generate(
            for: entries,
            sourceLanguage: "en",
            developmentRegion: "en"
        )
        
        let jsonObject = try JSONSerialization.jsonObject(with: data)
        #expect(jsonObject is [String: Any], "Special characters should not break JSON parsing")
        
        let jsonString = String(data: data, encoding: .utf8)!
        #expect(jsonString.contains("ðŸš€"), "Unicode emoji characters should be preserved")
        #expect(jsonString.contains("Ã¡Ã©Ã­Ã³Ãº"), "Accented characters should be preserved")
    }
    
    @Test("StringsCatalogGenerator generates consistent key format from LocalizationEntry components")
    func stringsCatalogGeneratorKeyFormatValidation() throws {
        let entry = LocalizationEntry(
            view: "profile",
            item: "user_count",
            type: "text",
            translations: ["en": "Users"]
        )
        
        let data = try StringsCatalogGenerator.generate(
            for: [entry],
            sourceLanguage: "en",
            developmentRegion: "en"
        )
        
        let jsonString = String(data: data, encoding: .utf8)!
        
        #expect(jsonString.contains("\"profile_user_count_text\""), "Generated key should follow view_item_type naming convention")
    }
}
