import Testing
import Foundation
@testable import SheetLocalizer

@Suite("SwiftEnumGenerator Tests")
struct SwiftEnumGeneratorTest {
    
    // MARK: - Basic Functionality Tests
    
    @Test("SwiftEnumGenerator creates comprehensive localization enums with proper structure and methods",
          arguments: [
              (["common_app_name_text"], "L10n"),
              (["login_title_text", "profile_version_text"], "AppStrings"),
              (["common_app_name_text", "login_title_text", "profile_version_text"], "Localizable")
          ])
    func createLocalizationEnum(keys: [String], enumName: String) {
        let generator = SwiftEnumGenerator(enumName: enumName)
        let result = generator.generateCode(allKeys: keys)
        
        #expect(!result.isEmpty)
        
        // Verify header and metadata
        #expect(result.contains("// Auto-generated by SheetLocalizer — do not edit"))
        #expect(result.contains("// Generated on:"))
        
        // Verify imports and enum declaration
        #expect(result.contains("import Foundation"))
        #expect(result.contains("import SwiftUI"))
        #expect(result.contains("@frozen"))
        #expect(result.contains("public enum \(enumName): String, CaseIterable, Sendable"))
        
        // Verify each key generates a case
        for key in keys {
            #expect(result.contains("= \"\(key)\""))
        }
    }
    
    @Test("Generated enum includes all required localization methods")
    func includesLocalizationMethods() {
        let generator = SwiftEnumGenerator(enumName: "TestEnum")
        let result = generator.generateCode(allKeys: ["test_key"])
        
        // Basic localized property
        #expect(result.contains("public var localized: String"))
        #expect(result.contains("NSLocalizedString(self.rawValue, bundle: .main, comment: \"\")"))
        
        // Parameterized localization method
        #expect(result.contains("public func localized(_ args: CVarArg...) -> String"))
        #expect(result.contains("String(format: localized, arguments: args)"))
        
        // Custom bundle method
        #expect(result.contains("public func localized(bundle: Bundle) -> String"))
        #expect(result.contains("NSLocalizedString(self.rawValue, bundle: bundle, comment: \"\")"))
        
        // SwiftUI LocalizedStringKey property
        #expect(result.contains("@available(iOS 13.0, macOS 10.15, *)"))
        #expect(result.contains("public var localizedString: LocalizedStringKey"))
        #expect(result.contains("LocalizedStringKey(self.rawValue)"))
    }
    
    // MARK: - Identifier Sanitization Tests
    
    @Test("SwiftEnumGenerator handles edge cases gracefully",
          arguments: [
              ([], "Empty keys"),
              (["test_key_1", "test.key.1", "test-key-1"], "Special characters"),
              (["123numberStart", "primary-color-1"], "Invalid identifiers")
          ])
    func handleEdgeCases(keys: [String], description: String) {
        let generator = SwiftEnumGenerator(enumName: "TestEnum")
        let result = generator.generateCode(allKeys: keys)
        
        if keys.isEmpty {
            // Should still generate valid enum structure
            #expect(result.contains("public enum TestEnum"))
            #expect(result.contains("CaseIterable"))
            #expect(result.contains("public var localized: String"))
        } else {
            #expect(!result.isEmpty)
            #expect(result.contains("case "))
            
            // Verify each key produces a valid Swift identifier
            for key in keys {
                #expect(result.contains("= \"\(key)\""))
            }
        }
    }
    
    @Test("Identifier sanitization converts invalid characters to valid Swift identifiers")
    func sanitizesInvalidIdentifiers() {
        let generator = SwiftEnumGenerator(enumName: "TestEnum")
        
        // Test various problematic characters
        let testCases: [(input: String, expectedPattern: String)] = [
            ("common-app-name", "_app_name"), // Hyphens to underscores, camelCase
            ("login.title.text", "_title_text"), // Dots removed, camelCase
            ("123numberStart", "_123numberStart"), // Numbers at start get prefix
            ("profile_version_text", "profile_version_text"), // Already valid
            ("test@symbol#here", "test_symbol_here"), // Special chars removed
            ("", "_"), // Empty string gets underscore
            ("!@#$%", "_"), // All special chars removed
            ("common app name", "common_app_name") // Spaces to underscores
        ]
        
        for (input, _) in testCases {
            let result = generator.generateCode(allKeys: [input])
            #expect(result.contains("case "))
            #expect(result.contains("= \"\(input)\""))
        }
    }
    
    @Test("Identifier sanitization produces valid camelCase identifiers")
    func producesValidCamelCase() {
        let generator = SwiftEnumGenerator(enumName: "TestEnum")
        
        let testKeys = [
            "common_app_name_text",
            "login_title_button", 
            "profile_user_count_text",
            "settings_notification_toggle"
        ]
        
        let result = generator.generateCode(allKeys: testKeys)
        
        // Verify camelCase conversion
        #expect(result.contains("case commonAppNameText"))
        #expect(result.contains("case loginTitleButton"))
        #expect(result.contains("case profileUserCountText"))
        #expect(result.contains("case settingsNotificationToggle"))
    }
    
    // MARK: - Code Structure Tests
    
    @Test("Generated enum has proper Swift syntax and structure")
    func hasProperSwiftSyntax() {
        let generator = SwiftEnumGenerator(enumName: "SyntaxTest")
        let keys = ["test_key_1", "test_key_2", "test_key_3"]
        let result = generator.generateCode(allKeys: keys)
        
        // Verify enum declaration syntax
        #expect(result.contains("@frozen"))
        #expect(result.contains("public enum SyntaxTest: String, CaseIterable, Sendable {"))
        
        // Verify case syntax
        for key in keys {
            #expect(result.contains("case "))
            #expect(result.contains(" = \"\(key)\""))
        }
        
        // Verify method syntax
        #expect(result.contains("public var localized: String {"))
        #expect(result.contains("public func localized(_ args: CVarArg...) -> String {"))
        #expect(result.contains("public func localized(bundle: Bundle) -> String {"))
        
        // Verify closing brace
        let lines = result.components(separatedBy: "\n")
        #expect(lines.last?.trimmingCharacters(in: .whitespaces) == "}")
        
        // Verify balanced braces
        let openBraces = result.components(separatedBy: "{").count - 1
        let closeBraces = result.components(separatedBy: "}").count - 1
        #expect(openBraces == closeBraces)
    }
    
    @Test("Generated code includes proper availability annotations")
    func includesAvailabilityAnnotations() {
        let generator = SwiftEnumGenerator(enumName: "AvailabilityTest")
        let result = generator.generateCode(allKeys: ["test"])
        
        #expect(result.contains("@available(iOS 13.0, macOS 10.15, *)"))
        #expect(result.contains("public var localizedString: LocalizedStringKey"))
    }
    
    // MARK: - Large Dataset Tests
    
    @Test("Handles large numbers of localization keys efficiently")
    func handlesLargeDatasets() {
        let generator = SwiftEnumGenerator(enumName: "LargeEnum")
        
        // Generate 1000 test keys
        let largeKeySet = (0..<1000).map { "test_key_\($0)" }
        
        let startTime = CFAbsoluteTimeGetCurrent()
        let result = generator.generateCode(allKeys: largeKeySet)
        let endTime = CFAbsoluteTimeGetCurrent()
        
        let executionTime = endTime - startTime
        #expect(executionTime < 1.0, "Should handle 1000 keys within 1 second")
        
        // Verify all keys are included
        for key in largeKeySet.prefix(10) { // Check first 10 for performance
            #expect(result.contains("= \"\(key)\""))
        }
        
        // Verify structure integrity
        #expect(result.contains("public enum LargeEnum"))
        #expect(result.contains("public var localized: String"))
    }
    
    // MARK: - Unicode and Special Character Tests
    
    @Test("Handles Unicode and international characters correctly")
    func handlesUnicodeCharacters() {
        let generator = SwiftEnumGenerator(enumName: "UnicodeEnum")
        
        let unicodeKeys = [
            "español_título_texto",
            "français_bouton_connexion",
            "中文_按钮_文本",
            "العربية_زر_النص",
            "हिंदी_बटन_टेक्स्ट",
            "русский_кнопка_текст"
        ]
        
        let result = generator.generateCode(allKeys: unicodeKeys)
        
        // Unicode characters should be preserved in raw values
        for key in unicodeKeys {
            #expect(result.contains("= \"\(key)\""))
        }
        
        // Generated identifiers should be safe Swift identifiers
        #expect(result.contains("case "))
        #expect(result.contains("public enum UnicodeEnum"))
    }
    
    // MARK: - Integration Tests
    
    @Test("Generated enum integrates properly with localization system")
    func integratesWithLocalizationSystem() {
        let generator = SwiftEnumGenerator(enumName: "IntegrationTest")
        let keys = ["common_app_name", "login_title", "profile_version"]
        let result = generator.generateCode(allKeys: keys)
        
        // Verify NSLocalizedString usage
        #expect(result.contains("NSLocalizedString(self.rawValue, bundle: .main, comment: \"\")"))
        #expect(result.contains("NSLocalizedString(self.rawValue, bundle: bundle, comment: \"\")"))
        
        // Verify String formatting support
        #expect(result.contains("String(format: localized, arguments: args)"))
        
        // Verify SwiftUI integration
        #expect(result.contains("LocalizedStringKey(self.rawValue)"))
        
        // Verify all protocol conformances
        #expect(result.contains(": String, CaseIterable, Sendable"))
    }
    
    // MARK: - Edge Case Tests
    
    @Test("Handles reserved Swift keywords correctly")
    func handlesReservedKeywords() {
        let generator = SwiftEnumGenerator(enumName: "KeywordTest")
        
        let reservedKeywords = [
            "class", "struct", "enum", "protocol", "var", "let", 
            "func", "init", "deinit", "import", "if", "else",
            "for", "while", "switch", "case", "default", "break",
            "continue", "return", "private", "public", "internal"
        ]
        
        let result = generator.generateCode(allKeys: reservedKeywords)
        
        #expect(result.contains("public enum KeywordTest"))
        #expect(result.contains("case "))
        
        for keyword in reservedKeywords.prefix(5) { // Test first 5 for performance
            #expect(result.contains("= \"\(keyword)\""))
        }
    }
    
    @Test("Generates consistent output for same input")
    func generatesConsistentOutput() {
        let generator = SwiftEnumGenerator(enumName: "ConsistencyTest")
        let keys = ["test_1", "test_2", "test_3"]
        
        let result1 = generator.generateCode(allKeys: keys)
        let result2 = generator.generateCode(allKeys: keys)
        
        // Results should be identical except for timestamp
        let lines1 = result1.components(separatedBy: "\n")
        let lines2 = result2.components(separatedBy: "\n")
        
        #expect(lines1.count == lines2.count)
        
        for (line1, line2) in zip(lines1, lines2) {
            if !line1.contains("Generated on:") {
                #expect(line1 == line2)
            }
        }
    }
    
    // MARK: - Performance Tests
    
    @Test("SwiftEnumGenerator includes proper generation metadata")
    func includesGenerationMetadata() {
        let generator = SwiftEnumGenerator(enumName: "MetadataTest")
        let result = generator.generateCode(allKeys: ["test"])
        
        #expect(result.contains("// Auto-generated by SheetLocalizer — do not edit"))
        #expect(result.contains("// Generated on:"))
        
        let lines = result.components(separatedBy: "\n")
        let timestampLine = lines.first { $0.contains("Generated on:") }
        #expect(timestampLine != nil)
        
        if let timestamp = timestampLine {
            #expect(timestamp.count > 20) // Reasonable timestamp length
        }
    }
}
