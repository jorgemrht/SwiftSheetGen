import Testing
import Foundation
@testable import SheetLocalizer

@Suite
struct FileGeneratorTests {
    
    // MARK: - SwiftEnumGenerator Tests
    
    @Test("SwiftEnumGenerator creates comprehensive localization enums with proper structure and methods",
          arguments: [
              (["common_app_name_text"], "L10n"),
              (["login_title_text", "profile_version_text"], "AppStrings"),
              (["common_app_name_text", "login_title_text", "profile_version_text"], "Localizable")
          ])
    func swiftEnumGeneratorCodeGeneration(keys: [String], enumName: String) {
        let generator = SwiftEnumGenerator(enumName: enumName)
        let code = generator.generateCode(allKeys: keys)
        
        #expect(code.contains("public enum \(enumName): String, CaseIterable, Sendable"))
        #expect(code.contains("@frozen"))
        #expect(code.contains("import Foundation"))
        #expect(code.contains("import SwiftUI"))
        
        for key in keys {
            let camelCase = key.replacingOccurrences(of: "_", with: " ")
                              .replacingOccurrences(of: "-", with: " ")
                              .split(separator: " ")
                              .enumerated()
                              .map { $0.offset == 0 ? $0.element.lowercased() : $0.element.capitalized }
                              .joined()
            #expect(code.contains("case \(camelCase) = \"\(key)\""))
        }
        
        #expect(code.contains("public var localized: String"))
        #expect(code.contains("public func localized(_ args: CVarArg...) -> String"))
        #expect(code.contains("public func localized(bundle: Bundle) -> String"))
        #expect(code.contains("public var localizedString: LocalizedStringKey"))
    }
    
    @Test("SwiftEnumGenerator handles edge cases gracefully",
          arguments: [
              ([], "Empty keys"),
              (["test_key_1", "test.key.1", "test-key-1"], "Special characters"),
              (["123numberStart", "primary-color-1"], "Invalid identifiers")
          ])
    func swiftEnumGeneratorEdgeCases(keys: [String], description: String) {
        let generator = SwiftEnumGenerator(enumName: "TestEnum")
        let code = generator.generateCode(allKeys: keys)
        
        #expect(code.contains("public enum TestEnum: String, CaseIterable, Sendable"))
        #expect(code.contains("public var localized: String"))
        
        for key in keys {
            #expect(code.contains("= \"\(key)\""), "Original key values should be preserved: \(key)")
        }
    }
    
    @Test("SwiftEnumGenerator includes proper generation metadata")
    func swiftEnumGeneratorMetadata() {
        let generator = SwiftEnumGenerator(enumName: "L10n")
        let code = generator.generateCode(allKeys: ["test_key"])
        
        #expect(code.contains("Auto-generated by SheetLocalizer"))
        #expect(code.contains("Generated on:"))
        #expect(code.contains("do not edit"))
    }
    
    @Test("Complete workflows generate consistent and coordinated file outputs",
          arguments: [
              ("localization", true),
              ("color", false)
          ])
    func completeWorkflowIntegration(workflowType: String, isLocalization: Bool) throws {
        if isLocalization {
            let entries = [
                LocalizationEntry(view: "common", item: "app_name", type: "text", translations: [
                    "en": "My App", "es": "Mi Aplicación", "fr": "Mon App"
                ]),
                LocalizationEntry(view: "login", item: "title", type: "text", translations: [
                    "en": "Login", "es": "Iniciar Sesión", "fr": "Connexion"
                ])
            ]
            
            let enumCode = SwiftEnumGenerator(enumName: "L10n").generateCode(allKeys: entries.map(\.key).sorted())
            let catalogData = try StringsCatalogGenerator.generate(for: entries, sourceLanguage: "en", developmentRegion: "en")
            
            #expect(enumCode.contains("public enum L10n: String, CaseIterable, Sendable"))
            #expect(enumCode.contains("case commonAppNameText"))
            #expect(enumCode.contains("case loginTitleText"))
            
            let catalog = try JSONSerialization.jsonObject(with: catalogData) as! [String: Any]
            #expect(catalog["sourceLanguage"] as? String == "en")
            #expect((catalog["strings"] as! [String: Any]).count == 2)
        } else {
            let colorEntries = [
                ColorEntry(name: "primaryBackground", anyHex: nil, lightHex: "#FFFFFF", darkHex: "#000000"),
                ColorEntry(name: "accentColor", anyHex: nil, lightHex: "#007AFF", darkHex: "#0056CC")
            ]
            
            let staticCode = ColorFileGenerator().generateCode(entries: colorEntries)
            let dynamicCode = ColorDynamicFileGenerator().generateCode()
            
            #expect(staticCode.contains("import SwiftUI") && dynamicCode.contains("import SwiftUI"))
            #expect(staticCode.contains("primaryBackground") || staticCode.contains("Primary"))
            #expect(dynamicCode.contains("extension Color"))
        }
    }
    
    
    @Test("End-to-end generation maintains consistency across all file types")
    func endToEndGenerationConsistency() throws {
        let locEntry = LocalizationEntry(view: "settings", item: "privacy", type: "title", translations: ["en": "Privacy Settings", "es": "Configuración de Privacidad"])
        let colorEntry = ColorEntry(name: "settingsBackground", anyHex: nil, lightHex: "#F5F5F5", darkHex: "#1C1C1E")
        
        let enumCode = SwiftEnumGenerator(enumName: "AppStrings").generateCode(allKeys: [locEntry.key])
        let catalogData = try StringsCatalogGenerator.generate(for: [locEntry], sourceLanguage: "en", developmentRegion: "en")
        let colorsCode = ColorFileGenerator().generateCode(entries: [colorEntry])
        let dynamicCode = ColorDynamicFileGenerator().generateCode()
        
        #expect(enumCode.contains("enum AppStrings") && enumCode.contains("settingsPrivacyTitle"))
        #expect(!catalogData.isEmpty)
        #expect(colorsCode.contains("settingsBackground"))
        #expect(dynamicCode.contains("extension Color"))
        
        let catalog = try JSONSerialization.jsonObject(with: catalogData) as! [String: Any]
        #expect((catalog["strings"] as! [String: Any])["settings_privacy_title"] != nil)
    }
}
